"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_uri_1 = require("vscode-uri");
const path_1 = require("path");
const fg = require("glob");
const config_1 = require("./config");
const client_1 = require("./project/client");
const service_1 = require("./project/service");
class GraphQLWorkspace {
    constructor(LanguageServerLoadingHandler, config) {
        this.LanguageServerLoadingHandler = LanguageServerLoadingHandler;
        this.config = config;
        this.projectsByFolderUri = new Map();
    }
    onDiagnostics(handler) {
        this._onDiagnostics = handler;
    }
    onDecorations(handler) {
        this._onDecorations = handler;
    }
    onSchemaTags(handler) {
        this._onSchemaTags = handler;
    }
    createProject(config, folder) {
        const { clientIdentity } = this.config;
        const project = config_1.isClientConfig(config)
            ? new client_1.GraphQLClientProject({
                config,
                loadingHandler: this.LanguageServerLoadingHandler,
                rootURI: folder.uri,
                clientIdentity
            })
            : new service_1.GraphQLServiceProject({
                config: config,
                loadingHandler: this.LanguageServerLoadingHandler,
                rootURI: folder.uri,
                clientIdentity
            });
        project.onDiagnostics(params => {
            this._onDiagnostics && this._onDiagnostics(params);
        });
        if (client_1.isClientProject(project)) {
            project.onDecorations(params => {
                this._onDecorations && this._onDecorations(params);
            });
            project.onSchemaTags(tags => {
                this._onSchemaTags && this._onSchemaTags(tags);
            });
        }
        return project;
    }
    async addProjectsInFolder(folder) {
        const apolloConfigFiles = fg.sync("**/apollo.config.@(js|ts)", {
            cwd: vscode_uri_1.default.parse(folder.uri).fsPath,
            absolute: true,
            ignore: "**/node_modules/**"
        });
        apolloConfigFiles.push(...fg.sync("**/package.json", {
            cwd: vscode_uri_1.default.parse(folder.uri).fsPath,
            absolute: true,
            ignore: "**/node_modules/**"
        }));
        const apolloConfigFolders = new Set(apolloConfigFiles.map(f => path_1.dirname(f)));
        const projectConfigs = Array.from(apolloConfigFolders).map(configFolder => this.LanguageServerLoadingHandler.handle(`Loading Apollo Config in folder ${configFolder}`, (async () => {
            try {
                const config = await config_1.loadConfig({ configPath: configFolder });
                return config && config.config;
            }
            catch (e) {
                console.error(e);
                return null;
            }
        })()));
        await Promise.all(projectConfigs)
            .then(configs => configs.filter(Boolean).flatMap(projectConfig => {
            return projectConfig.projects.map(config => {
                return this.createProject(config, folder);
            });
        }))
            .then(projects => this.projectsByFolderUri.set(folder.uri, projects))
            .catch(error => {
            console.error(error);
        });
    }
    reloadService() {
        this.projectsByFolderUri.forEach((projects, uri) => {
            this.projectsByFolderUri.set(uri, projects.map(project => {
                project.clearAllDiagnostics();
                return this.createProject(project.config, { uri });
            }));
        });
    }
    updateSchemaTag(selection) {
        const serviceID = selection.detail;
        if (!serviceID)
            return;
        this.projectsByFolderUri.forEach(projects => {
            projects.forEach(project => {
                if (client_1.isClientProject(project) && project.serviceID === serviceID) {
                    project.updateSchemaTag(selection.label);
                }
            });
        });
    }
    removeProjectsInFolder(folder) {
        const projects = this.projectsByFolderUri.get(folder.uri);
        if (projects) {
            projects.forEach(project => project.clearAllDiagnostics());
            this.projectsByFolderUri.delete(folder.uri);
        }
    }
    get projects() {
        return Array.from(this.projectsByFolderUri.values()).flat();
    }
    projectForFile(uri) {
        for (const projects of this.projectsByFolderUri.values()) {
            const project = projects.find(project => project.includesFile(uri));
            if (project) {
                return project;
            }
        }
        return undefined;
    }
}
exports.GraphQLWorkspace = GraphQLWorkspace;
//# sourceMappingURL=workspace.js.map