"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_tag_1 = require("graphql-tag");
const GraphQLDataSource_1 = require("./GraphQLDataSource");
const config_1 = require("../config");
const checkSchema_1 = require("./operations/checkSchema");
const uploadSchema_1 = require("./operations/uploadSchema");
const checkOperations_1 = require("./operations/checkOperations");
const registerOperations_1 = require("./operations/registerOperations");
const SCHEMA_TAGS_AND_FIELD_STATS = graphql_tag_1.default `
  query SchemaTagsAndFieldStats($id: ID!) {
    service(id: $id) {
      schemaTags {
        tag
      }
      stats(from: "-86400", to: "-0") {
        fieldStats {
          groupBy {
            field
          }
          metrics {
            fieldHistogram {
              durationMs(percentile: 0.95)
            }
          }
        }
      }
    }
  }
`;
function noServiceError(service, endpoint) {
    return `Could not find service ${service ? service : ""} from Engine at ${endpoint}. Please check your API key and service name`;
}
exports.noServiceError = noServiceError;
const getServiceFromKey = (key) => {
    if (!key)
        return "";
    const [type, service] = key.split(":");
    if (type === "service")
        return service;
    return;
};
class ApolloEngineClient extends GraphQLDataSource_1.GraphQLDataSource {
    constructor(engineKey, engineEndpoint = config_1.DefaultEngineConfig.endpoint, clientIdentity) {
        super();
        this.engineKey = engineKey;
        this.clientIdentity = clientIdentity;
        this.baseURL = engineEndpoint;
    }
    willSendRequest(request) {
        if (!request.headers)
            request.headers = {};
        request.headers["x-api-key"] = this.engineKey;
        if (this.clientIdentity && this.clientIdentity.name) {
            request.headers["apollo-client-name"] = this.clientIdentity.name;
            request.headers["apollo-client-reference-id"] = this.clientIdentity.referenceID;
            request.headers["apollo-client-version"] = this.clientIdentity.version;
            return;
        }
        request.headers["apollo-client-name"] = "Apollo Language Server";
        request.headers["apollo-client-reference-id"] =
            "146d29c0-912c-46d3-b686-920e52586be6";
        request.headers["apollo-client-version"] = require("../../package.json").version;
    }
    async execute(options) {
        return super.query(options.query, options).then(result => result || {});
    }
    async checkSchema(variables) {
        return this.execute({
            query: checkSchema_1.CHECK_SCHEMA,
            variables
        }).then(({ data, errors }) => {
            if (data && !data.service) {
                throw new Error(noServiceError(getServiceFromKey(this.engineKey), this.baseURL));
            }
            if (errors) {
                throw new Error(errors.map(error => error.message).join("\n"));
            }
            if (!data) {
                throw new Error("Error in request from Engine");
            }
            return data.service.checkSchema;
        });
    }
    async uploadSchema(variables) {
        return this.execute({
            query: uploadSchema_1.UPLOAD_SCHEMA,
            variables
        }).then(({ data, errors }) => {
            if (data && !data.service) {
                throw new Error(noServiceError(getServiceFromKey(this.engineKey), this.baseURL));
            }
            if (errors) {
                throw new Error(errors.map(error => error.message).join("\n"));
            }
            if (!data) {
                throw new Error("Error in request from Engine");
            }
            return data.service.uploadSchema;
        });
    }
    async checkOperations(variables) {
        return this.execute({ query: checkOperations_1.CHECK_OPERATIONS, variables }).then(({ data, errors }) => {
            if (data && !data.service) {
                throw new Error(noServiceError(getServiceFromKey(this.engineKey), this.baseURL));
            }
            if (errors) {
                throw new Error(errors.map(error => error.message).join("\n"));
            }
            if (!data) {
                throw new Error("Error in request from Engine");
            }
            return data.service.checkOperations;
        });
    }
    async registerOperations(variables) {
        return this.execute({ query: registerOperations_1.REGISTER_OPERATIONS, variables }).then(({ data, errors }) => {
            if (data && !data.service) {
                throw new Error(noServiceError(getServiceFromKey(this.engineKey), this.baseURL));
            }
            if (errors) {
                throw new Error(errors.map(error => error.message).join("\n"));
            }
            if (!data) {
                throw new Error("Error in request from Engine");
            }
            return data.service.registerOperations;
        });
    }
    async loadSchemaTagsAndFieldStats(serviceID) {
        const result = await this.execute({
            query: SCHEMA_TAGS_AND_FIELD_STATS,
            variables: {
                id: serviceID
            }
        });
        if (!result.data) {
            throw new Error();
        }
        const schemaTags = result.data.service.schemaTags.map(({ tag }) => tag);
        const fieldStats = new Map();
        result.data.service.stats.fieldStats.forEach((fieldStat) => {
            const [parentType = null, fieldName = null] = fieldStat.groupBy.field.split(/\.|:/) || [];
            if (!parentType || !fieldName) {
                return;
            }
            const fieldsMap = fieldStats.get(parentType) ||
                fieldStats.set(parentType, new Map()).get(parentType);
            fieldsMap.set(fieldName, fieldStat.metrics.fieldHistogram.durationMs);
        });
        return [schemaTags, fieldStats];
    }
}
exports.ApolloEngineClient = ApolloEngineClient;
//# sourceMappingURL=index.js.map