"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const apollo_engine_reporting_1 = require("apollo-engine-reporting");
const graphql_1 = require("graphql");
const Command_1 = require("../../Command");
const manifestOperationHash = (str) => crypto_1.createHash("sha256")
    .update(str)
    .digest("hex");
const engineSignature = (_TODO_operationAST) => {
    return apollo_engine_reporting_1.defaultSignature(_TODO_operationAST, "TODO");
};
function hideCertainLiterals(ast) {
    return graphql_1.visit(ast, {
        IntValue(node) {
            return Object.assign({}, node, { value: "0" });
        },
        FloatValue(node) {
            return Object.assign({}, node, { value: "0" });
        },
        StringValue(node) {
            return Object.assign({}, node, { value: "", block: false });
        }
    });
}
exports.hideCertainLiterals = hideCertainLiterals;
class ServicePush extends Command_1.ClientCommand {
    async run() {
        const { clientIdentity, operations, serviceName } = await this.runTasks(({ flags, project, config }) => [
            {
                title: "Pushing client information to Engine",
                task: async (ctx) => {
                    if (!config.name) {
                        throw new Error("No service found to link to Engine");
                    }
                    const operations = Object.values(this.project.mergedOperationsAndFragmentsForService).map(operationAST => {
                        const printed = apollo_engine_reporting_1.printWithReducedWhitespace(apollo_engine_reporting_1.sortAST(hideCertainLiterals(operationAST)));
                        return {
                            signature: manifestOperationHash(printed),
                            document: printed,
                            metadata: {
                                engineSignature: engineSignature(operationAST)
                            }
                        };
                    });
                    const { name, referenceID, version } = config.client;
                    if (!name) {
                        throw new Error("Client name is required to push");
                    }
                    const variables = {
                        clientIdentity: {
                            name: name,
                            identifier: referenceID || name,
                            version
                        },
                        id: config.name,
                        operations
                    };
                    await project.engine.registerOperations(variables);
                    ctx.operations = operations;
                    ctx.serviceName = variables.id;
                    ctx.clientIdentity = variables.clientIdentity;
                }
            }
        ]);
        this.log(`Successfully pushed ${operations.length} operations from the ${clientIdentity.name} client to the ${serviceName} service in Engine`);
    }
}
ServicePush.description = "Push a service to Engine";
ServicePush.flags = Object.assign({}, Command_1.ClientCommand.flags);
exports.default = ServicePush;
//# sourceMappingURL=push.js.map