"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const heroku_cli_util_1 = require("heroku-cli-util");
const graphql_1 = require("graphql");
const git_1 = require("../../git");
const diff_1 = require("../../diff");
const Command_1 = require("../../Command");
class ClientCheck extends Command_1.ClientCommand {
    async run() {
        const { changes, operations } = await this.runTasks(({ flags, project, config }) => [
            {
                title: "Checking client compatibility with service",
                task: async (ctx) => {
                    if (!config.name) {
                        throw new Error("No service found to link to Engine");
                    }
                    ctx.gitContext = await git_1.gitInfo();
                    ctx.operations = Object.values(this.project.mergedOperationsAndFragmentsForService).map(doc => ({ document: graphql_1.print(doc) }));
                    const { changes } = await project.engine.checkOperations({
                        id: config.name,
                        operations: ctx.operations,
                        tag: flags.tag,
                        gitContext: ctx.gitContext
                    });
                    ctx.changes = changes;
                }
            }
        ]);
        const failures = changes.filter(({ type }) => type === diff_1.ChangeType.FAILURE);
        const count = operations.length;
        this.log(`\n${count} operations extracted and validated`);
        if (changes.length === 0) {
            return this.log("\nAll operations are valid against service\n");
        }
        this.log("\n");
        heroku_cli_util_1.table(changes.map(diff_1.format), {
            columns: [
                { key: "type", label: "Change" },
                { key: "code", label: "Code" },
                { key: "description", label: "Description" }
            ]
        });
        this.log("\n");
        if (failures.length > 0) {
            this.exit();
        }
        return;
    }
}
ClientCheck.description = "Check a client project against a pushed service";
ClientCheck.flags = Object.assign({}, Command_1.ClientCommand.flags, { tag: command_1.flags.string({
        char: "t",
        description: "The published tag to check this client against",
        default: "current"
    }) });
exports.default = ClientCheck;
//# sourceMappingURL=check.js.map