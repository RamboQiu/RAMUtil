"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const Listr = require("listr");
const path_1 = require("path");
const apollo_language_server_1 = require("apollo-language-server");
const OclifLoadingHandler_1 = require("./OclifLoadingHandler");
const { version, referenceID } = require("../package.json");
const headersArrayToObject = (arr) => {
    if (!arr)
        return;
    return arr
        .map(val => JSON.parse(val))
        .reduce((pre, next) => (Object.assign({}, pre, next)), {});
};
const getServiceFromKey = (key) => {
    const [type, service] = key.split(":");
    if (type === "service")
        return service;
    return;
};
class ProjectCommand extends command_1.default {
    constructor() {
        super(...arguments);
        this.tasks = [];
        this.type = "service";
    }
    async init() {
        const { flags, args } = this.parse(this.constructor);
        this.ctx = { flags, args };
        const { config, filepath } = await this.createConfig(flags);
        this.createService(config, filepath, flags);
        (this.ctx.config = config),
            this.tasks.push({
                title: "Loading Apollo Project",
                task: async (ctx) => {
                    await this.project.whenReady;
                    ctx = Object.assign({}, ctx, this.ctx);
                }
            });
    }
    async createConfig(flags) {
        const service = flags.key ? getServiceFromKey(flags.key) : undefined;
        const loadedConfig = await apollo_language_server_1.loadConfig({
            configPath: flags.config,
            name: service,
            type: this.type
        });
        const { config, filepath, isEmpty } = loadedConfig;
        if (flags.tag)
            config.tag = flags.tag;
        config.setDefaults({
            engine: {
                apiKey: flags.key,
                endpoint: flags.engine,
                frontend: flags.frontend
            }
        });
        if (flags.endpoint) {
            config.setDefaults({
                service: {
                    endpoint: Object.assign({ url: flags.endpoint, headers: headersArrayToObject(flags.header) }, (flags.skipSSLValidation && { skipSSLValidation: true }))
                }
            });
        }
        if (flags.localSchemaFile) {
            if (apollo_language_server_1.isClientConfig(config)) {
                config.setDefaults({
                    client: {
                        service: {
                            localSchemaFile: flags.localSchemaFile
                        }
                    }
                });
            }
            else if (apollo_language_server_1.isServiceConfig(config)) {
                config.setDefaults({
                    service: {
                        localSchemaFile: flags.localSchemaFile
                    }
                });
            }
        }
        if (this.configMap) {
            const defaults = this.configMap(flags);
            config.setDefaults(defaults);
        }
        return { config, filepath, isEmpty };
    }
    createService(config, filepath, flags) {
        const loadingHandler = new OclifLoadingHandler_1.OclifLoadingHandler(this);
        const rootURI = filepath === process.cwd()
            ? `file://${filepath}`
            : `file://${path_1.parse(filepath).dir}`;
        const clientIdentity = {
            name: "Apollo CLI",
            version,
            referenceID
        };
        if (apollo_language_server_1.isServiceConfig(config)) {
            this.project = new apollo_language_server_1.GraphQLServiceProject({
                config,
                loadingHandler,
                rootURI,
                clientIdentity
            });
        }
        else if (apollo_language_server_1.isClientConfig(config)) {
            this.project = new apollo_language_server_1.GraphQLClientProject({
                config,
                loadingHandler,
                rootURI,
                clientIdentity
            });
        }
        this.ctx.project = this.project;
    }
    async runTasks(generateTasks) {
        const tasks = await generateTasks(this.ctx);
        return new Listr([...this.tasks, ...tasks]).run();
    }
    async catch(err) {
        this.error(err);
    }
    async finally(err) {
    }
}
ProjectCommand.flags = {
    config: command_1.flags.string({
        char: "c",
        description: "Path to your Apollo config file"
    }),
    header: command_1.flags.string({
        multiple: true,
        parse: header => {
            const separatorIndex = header.indexOf(":");
            const key = header.substring(0, separatorIndex).trim();
            const value = header.substring(separatorIndex + 1).trim();
            return JSON.stringify({ [key]: value });
        },
        description: "Additional headers to send to server for introspectionQuery"
    }),
    endpoint: command_1.flags.string({
        description: "The url of your service"
    }),
    key: command_1.flags.string({
        description: "The API key for the Apollo Engine service",
        default: () => process.env.ENGINE_API_KEY
    }),
    engine: command_1.flags.string({
        description: "Reporting URL for a custom Apollo Engine deployment",
        hidden: true
    }),
    frontend: command_1.flags.string({
        description: "URL for a custom Apollo Engine frontend",
        hidden: true
    })
};
exports.ProjectCommand = ProjectCommand;
class ClientCommand extends ProjectCommand {
    constructor(argv, config) {
        super(argv, config);
        this.type = "client";
        this.configMap = (flags) => {
            const config = {
                client: {
                    name: flags.clientName,
                    referenceID: flags.clientReferenceId,
                    version: flags.clientVersion
                }
            };
            if (flags.endpoint) {
                config.client.service = {
                    url: flags.endpoint,
                    headers: headersArrayToObject(flags.header)
                };
            }
            if (flags.includes || flags.queries) {
                config.client.includes = [flags.includes || flags.queries];
            }
            if (flags.excludes) {
                config.client.excludes = [flags.excludes];
            }
            if (flags.tagName) {
                config.client.tagName = flags.tagName;
            }
            return config;
        };
    }
}
ClientCommand.flags = Object.assign({}, ProjectCommand.flags, { clientReferenceId: command_1.flags.string({
        description: "Reference id for the client which will match ids from client traces, will use clientName if not provided"
    }), clientName: command_1.flags.string({
        description: "Name of the client that the queries will be attached to"
    }), clientVersion: command_1.flags.string({
        description: "The version of the client that the queries will be attached to"
    }), tag: command_1.flags.string({
        char: "t",
        description: "The published service tag for this client",
        default: "current"
    }), queries: command_1.flags.string({
        description: "Deprecated in favor of the includes flag"
    }), includes: command_1.flags.string({
        description: "Glob of files to search for GraphQL operations"
    }), excludes: command_1.flags.string({
        description: "Glob of files to exclude for GraphQL operations. Caveat: this doesn't currently work in watch mode"
    }), tagName: command_1.flags.string({
        description: "Name of the template literal tag used to identify template literals containing GraphQL queries in Javascript/Typescript code"
    }) });
exports.ClientCommand = ClientCommand;
//# sourceMappingURL=Command.js.map